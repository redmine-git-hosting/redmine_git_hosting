module GitHosting

  class GitoliteConfig

    DUMMY_REDMINE_KEY      = "redmine_dummy_key"
    ARCHIVED_REDMINE_KEY   = "redmine_archived_project"
    DISABLED_REDMINE_KEY   = "redmine_disabled_project"
    GIT_DAEMON_KEY         = "daemon"
    ADMIN_REPO             = "gitolite-admin"
    GITOLITE_CONFIG_FILE   = "gitolite.conf"
    DEFAULT_ADMIN_KEY_NAME = "redmine_git_hosting_admin_key"

    def self.gitolite_conf
      GitHostingConf.gitolite_config_file
    end

    def self.default_conf?
      gitolite_conf == GITOLITE_CONFIG_FILE
    end

    # Need admin key if conf file is default file or if there was an admin key.
    def self.has_admin_key?
      GitHostingConf.gitolite_config_has_admin_key? || default_conf?
    end

    def initialize file_path
      @path = file_path
      load
    end

    def save
      begin
        File.open(@path, "w") do |f|
          f.puts content_header
          f.puts content
        end
        @original_content = content
      rescue => e
        GitHosting.logger.error "Error trying to write config file: #{e.to_s}"
      end
    end

    def content_header
      plugin = Redmine::Plugin.find(:redmine_git_hosting)
      ["# File automatically generated by Redmine Git Hosting plugin.",
       "# #{plugin.url}",
       "# Manual changes will be preserved, with limitations.",
       "#",
       "# Last Update: #{Time.now}",
       "#",
       ""]
    end

    def add_write_user repo_name, users
      repository(repo_name).add "RW+", users.sort
    end

    def set_write_user repo_name, users
      repository(repo_name).set "RW+", users.sort
    end

    def add_read_user repo_name, users
      repository(repo_name).add "R", users.sort
    end

    def set_read_user repo_name, users
      repository(repo_name).set "R", users.sort
    end

    def mark_with_dummy_key repo_name
      add_read_user repo_name, [DUMMY_REDMINE_KEY]
    end

    def mark_archived repo_name
      add_read_user repo_name, [ARCHIVED_REDMINE_KEY]
    end

    def mark_disabled repo_name
      add_read_user repo_name, [DISABLED_REDMINE_KEY]
    end

    # Grab first admin key (assuming it exists)
    def get_admin_key
      (repository(ADMIN_REPO).get "RW+").first
    end

    # Grab all admin keys as a list
    def get_admin_keys
      repository(ADMIN_REPO).get "RW+"
    end

    def set_admin_keys keys
      repository(ADMIN_REPO).set "RW+", keys
    end

    def add_admin_keys keys
      repository(ADMIN_REPO).add "RW+", keys
    end

    def delete_admin_keys keys
      repository(ADMIN_REPO).delete "RW+", keys
    end

    def delete_repo repo_name
      @repositories.delete(repo_name)
    end

    def rename_repo old_name, new_name
      if @repositories.has_key?(old_name)
        perms = @repositories.delete(old_name)
        @repositories[new_name] = perms
      end
    end

    # A repository is a "redmine" repository if it has redmine keys or no keys
    # (latter case is checked, since we end up adding the DUMMY_REDMINE_KEY to
    # a repository with no keys anyway....
    def is_redmine_repo? repo_name
      repository(repo_name).rights.detect {|perm, users| users.detect {|key| is_redmine_key? key}} || (repo_has_no_keys? repo_name)
    end

    # Return true if repository has any redmine keys other than the DUMMY_REDMINE_KEY
    def has_actual_redmine_keys? repo_name
      repository(repo_name).rights.detect {|perm, users| users.detect {|key| GitolitePublicKey::ident_to_user_token(key)}}
    end

    # Delete all of the redmine keys from a repository
    # In addition, if there are any redmine keys, delete the GIT_DAEMON_KEY as well,
    # since we assume this under control of redmine server.
    def delete_redmine_keys repo_name
      return unless @repositories[repo_name] && is_redmine_repo?(repo_name)

      repository(repo_name).rights.each do |perm, users|
        users.delete_if {|key| ((is_redmine_key? key) || (is_daemon_key? key))}
      end
    end

    def repo_has_no_keys? repo_name
      !repository(repo_name).rights.detect {|perm, users| users.length > 0}
    end

    def is_redmine_key? keyname
      (GitolitePublicKey::ident_to_user_token(keyname) || keyname == DUMMY_REDMINE_KEY || keyname == ARCHIVED_REDMINE_KEY || keyname == DISABLED_REDMINE_KEY) ? true : false
    end

    def is_daemon_key? keyname
      (keyname == GIT_DAEMON_KEY)
    end

    def changed?
      @original_content != content
    end

    # For all repos in conf, return presence hash (hash of path=>last two components)
    # The presence of a path is quickly verified by looking it up.  The value returned
    # is used to say which project/repo it *might* belong to (this value used for recovery
    # code in closest_path(), called by update_repositories()).
    def all_repos
      repos = {}
      filesplit = /^.*?([^\/]+\/)?([^\/]+)$/
      @repositories.each do |repo, rights|
        repo =~ filesplit
        repos[repo] = "#{$1}#{$2}"
      end
      return repos
    end

    # For redmine repos in conf, return map of basename=>presence hash of paths with that basename
    # i.e. basename => { path1 => last two components, path2 => last two components, }
    # See all_repos() for description of why the value is what it is.
    def redmine_repo_map
      redmine_repos = Hash.new{|hash, key| hash[key] = {}}  # default -- empty hash
      filesplit = /^.*?([^\/]+\/)?([^\/]+)$/
      @repositories.each do |repo, rights|
        if is_redmine_repo? repo
          repo =~ filesplit
          redmine_repos[$2][repo] = "#{$1}#{$2}"
        end
      end
      return redmine_repos
    end

    # For all repositories, return map of basename=>presence hash of paths with that basename
    # i.e. basename => { path1 => last two components, path2 => last two components, }
    # See all_repos() for description of why the value is what it is.
    def self.gitolite_repository_map
      gitolite_repos = Hash.new{|hash, key| hash[key] = {}}  # default -- empty hash
      myfiles = %x[#{GitHosting.shell_cmd_runner} 'find #{GitHostingConf.gitolite_global_storage_dir} -type d -name "*.git" -prune -print'].chomp.split("\n")
      filesplit = /^(\.\/)*#{GitHostingConf.gitolite_global_storage_dir}(.*?([^\/]+\/)?([^\/]+))\.git$/
      myfiles.each do |nextfile|
        if filesplit =~ nextfile
          gitolite_repos[$4][$2] = "#{$3}#{$4}"
        end
      end
      gitolite_repos
    end

    private

    def load
      @original_content = []
      @repositories = ActiveSupport::OrderedHash.new
      if (File.exists? @path)
        begin
          cur_repo_name = nil
          File.open(@path).each_line do |raw_line|
            /^(.*?)(\s*#.*)?\n?$/.match(raw_line)
            next if $2 && ($1 == "")  # Remove comment-only lines entirely.
            line = $1+"\n"    # Remove comments from other lines
            @original_content << line
            tokens = line.strip.split
            if tokens.first == 'repo'
              cur_repo_name = tokens.last
              @repositories[cur_repo_name] = GitoliteAccessRights.new
              next
            end
            cur_repo_right = @repositories[cur_repo_name]
            if cur_repo_right and tokens[1] == '='
              cur_repo_right.add tokens.first, tokens[2..-1]
            end
          end

          # If no admin key in repo, delete any residual
          @repositories.delete(ADMIN_REPO) unless self.class.has_admin_key?

          @original_content = @original_content.join
        rescue => e
          GitHosting.logger.error "Error trying to read config file: #{e.to_s}"
        end
      else
        GitHosting.logger.info "Gitolite config file '#{@path}' does not exist, create it..."
        begin
          GitHosting.shell %x[ touch #{@path} ]
        rescue => e
          GitHosting.logger.error "Error trying to read config file: #{e.to_s}"
        end
      end
    end

    def repository repo_name
      @repositories[repo_name] ||= GitoliteAccessRights.new
    end

    def content
      content = []

      if self.class.has_admin_key?
        # Make sure that admin repo is first
        content << "repo\t#{ADMIN_REPO}"
        admin_key = @repositories[ADMIN_REPO] && (@repositories[ADMIN_REPO].get "RW+").first
        if admin_key.nil?
          # If no admin key with "RW+", put in a default -- will try to fix later if problem.
          content << "\tRW+\t=\t#{DEFAULT_ADMIN_KEY_NAME}"
        end
        @repositories[ADMIN_REPO].each do |perm, users|
          if users.length > 0
            content << "\t#{perm}\t=\t#{users.join(' ')}"
          end
        end unless @repositories[ADMIN_REPO].nil?
        content << ""
      end

      # Everything else
      @repositories.each do |repo, rights|
        unless repo == ADMIN_REPO
          content << "repo\t#{repo}"
          has_users = false
          rights.each do |perm, users|
            if users.length > 0
              has_users=true
              content << "\t#{perm}\t=\t#{users.join(' ')}"
            end
          end

          if !has_users
            # If no users, use dummy key to make sure repo created
            content << "\tR\t=\t#{DUMMY_REDMINE_KEY}"
          end
          content << ""
        end
      end

      return content.join("\n")
    end

  end

  class GitoliteAccessRights

    def initialize
      @rights = ActiveSupport::OrderedHash.new
    end

    def rights
      @rights
    end

    def add perm, users
      @rights[perm.to_sym] ||= []
      @rights[perm.to_sym] << users
      @rights[perm.to_sym].flatten!
      @rights[perm.to_sym].uniq!
    end

    def delete perm, users
      return if @rights[perm.to_sym].nil?
      if users.is_a?(Array)
        @rights[perm.to_sym] = @rights[perm.to_sym] - users
      else
        @rights[perm.to_sym].delete(users)
      end
    end

    def set perm, users
      @rights[perm.to_sym] = []
      add perm, users
    end

    def get perm
      @rights[perm.to_sym] || []
    end

    def each
      @rights.each {|k,v| yield k, v}
    end

  end

end
